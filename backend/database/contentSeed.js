import mongoose from "mongoose";
import Content from "../models/content.js";

export const contents = [
  {
    _id: "64af63f3c50d319acd12e5bd",
    primaryDescription:
      "Arrays are a data structure that can store a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it's better thought of as a collection of variables of the same type. Each item in an array, also referred to as an element, is allocated a unique index to distinguish it from the others. Indices usually start from zero, implying the first element is accessed using the zero index, the second element using index one, and so forth. For instance, if we have an array arr with elements [10, 20, 30, 40], arr[0] will give us the first element, which is 10." +
      "" +
      "Arrays have a fixed size, meaning once they are declared, their size cannot be changed. Therefore, the number of elements they will hold needs to be known at the time of creation. However, languages like JavaScript and Python offer dynamic arrays, which can expand or contract as needed.",
    secondaryDescription:
      "Arrays are commonly used because they allow easy access to elements based on their position. Accessing an element is a constant time operation, i.e., O(1), as you can directly reach the element with the index. Insertion and deletion, however, are linear time operations, i.e., O(n), because adding or removing elements may require shifting the rest of the elements." +
      "" +
      "Arrays can also be multi-dimensional, resembling a grid or table, useful for representing complex structures like matrices. For example, a two-dimensional array with three rows and two columns can be defined as int arr[3][2] in languages like C, C++, and Java." +
      "" +
      "Sorting and searching algorithms often use arrays, and understanding these can be particularly useful for technical interviews. Sorting algorithms, like Quick Sort and Merge Sort, arrange elements in a particular order, while searching algorithms, like Binary Search, help locate a specific element in an array.",
    videoURL: "https://www.youtube.com/embed/xzjZy-dHHLw",
    code: "\nint[] myArray = new int[5];  // Array declaration\nmyArray[0] = 5;  // Assigning values\nmyArray[1] = 10;\n// And so on...\n",
  },
  {
    _id: "64af69fde7b8e3839c5db07d",
    primaryDescription:
      'A stack is a linear data structure that follows a particular order in which operations are performed. The order may be LIFO (Last In First Out) or FILO (First In Last Out). Mainly, there are three fundamental operations that can be performed on stacks - pushing (adding) an element to the stack, popping (removing) the topmost element, and peeking (looking at) the topmost element without altering the stack. Because of this LIFO property, the last element inserted onto the stack is the first one to be deleted, which is why it\'s named a "stack", mimicking a real-world stack of plates or books.' +
      "" +
      "Stacks can be implemented using arrays or linked lists. For instance, in Python, we can use the built-in list structure as a stack. We can add elements to the list using the append() method (equivalent to push operation), and remove elements using the pop() method, which removes the last element in the list. To check the top of the stack, we can reference the last element in the list, e.g., stack[-1].",
    secondaryDescription:
      "Adding an element to the stack is known as a 'push' operation. Removing an element from the stack, or 'popping', only removes the topmost element. The 'peek' or 'top' operation allows you to see the current top of the stack without removing it. All of these operations are generally O(1), making stacks a very efficient data structure." +
      "" +
      "Stacks are fundamental in many operations in computer science and are used under the hood in recursion, function calls, undo operations in software applications, and even in parsing and evaluating expressions. They're a key component in certain algorithms like Depth-First Search (DFS), which is used to traverse trees and graphs." +
      "" +
      "Stacks can also be used to solve problems like balancing symbols (such as parentheses in an expression), tracking local variables in recursive functions, or even in backtracking algorithms. Understanding stacks and their application in algorithms will provide a solid foundation for handling more complex data structures and algorithms, a crucial aspect of cracking technical interviews.",
    videoURL: "https://www.youtube.com/embed/ILJgewz5Dxw",
    code: '\nimport java.util.Stack;\n\npublic class StackExample {\n    public static void main(String[] args) {\n        // Creating a Stack\n        Stack<Integer> stack = new Stack<Integer>();\n\n        // Pushing new items to the Stack\n        stack.push(10);\n        stack.push(15);\n        stack.push(30);\n        stack.push(20);\n        stack.push(5);\n\n        System.out.println("Stack: " + stack);\n\n        // Removing items using pop method\n        System.out.println("Pop Operation: " + stack.pop());\n        System.out.println("After Pop Operation: " + stack);\n\n        // Check item on top of stack\n        System.out.println("Current Top: " + stack.peek());\n\n        // Search item in the stack\n        System.out.println("Position of 15 : " + stack.search(15));\n        System.out.println("Position of 30 : " + stack.search(30));\n    }\n}',
  },
  {
    _id: "64af6b3a1dbd1835d54ade22",
    primaryDescription:
      "Binary search is an efficient algorithm for finding an item from a sorted list of items. It operates by dividing the search space in half at every step, which significantly reduces the time complexity to O(log n), making it much faster than linear search (O(n)) for larger lists. At each step, the algorithm compares the middle element in the search space with the target element. If they're equal, the position of the middle element is returned. If the target is greater than the middle element, the search continues in the upper half of the search space. Conversely, if the target is less than the middle element, the search continues in the lower half. By halving the search space at every step, binary search minimizes the number of comparisons and achieves logarithmic time complexity.",
    secondaryDescription:
      "Binary search can be implemented recursively or iteratively. Both methods keep reducing the search space until it's empty or the target is found. The iterative method uses a while loop and updates the bounds of the search space at each step, while the recursive method accomplishes the same by making a recursive call with updated bounds." +
      "" +
      "Binary search is used in a variety of practical applications. For instance, it's used in software version control systems to identify changes that introduced bugs (a technique known as 'bisecting'). It's also used in machine learning to train decision trees, and in databases and libraries to rapidly locate records. Understanding binary search is a fundamental skill in computer science and a common topic in technical interviews. Practicing binary search with different types of input will strengthen your problem-solving skills and help you recognize when and how to use this powerful algorithm.",
    videoURL: "https://www.youtube.com/embed/NFhOrxtXXcM",
    code: '\n// Java implementation of iterative Binary Search\n\nimport java.io.*;\n\nclass BinarySearch {\n\n    // Returns index of x if it is present in arr[].\n    int binarySearch(int arr[], int x)\n    {\n        int l = 0, r = arr.length - 1;\n        while (l <= r) {\n            int m = l + (r - l) / 2;\n\n            // Check if x is present at mid\n            if (arr[m] == x)\n                return m;\n\n            // If x greater, ignore left half\n            if (arr[m] < x)\n                l = m + 1;\n\n            // If x is smaller, ignore right half\n            else\n                r = m - 1;\n        }\n\n        // If we reach here, then element was\n        // not present\n        return -1;\n    }\n\n    // Driver code\n    public static void main(String args[])\n    {\n        BinarySearch ob = new BinarySearch();\n        int arr[] = { 2, 3, 4, 10, 40 };\n        int n = arr.length;\n        int x = 10;\n        int result = ob.binarySearch(arr, x);\n        if (result == -1)\n            System.out.println(\n                "Element is not present in array");\n        else\n            System.out.println("Element is present at "\n                               + "index " + result);\n    }\n}',
  },
  {
    _id: "64af740f8cb835b6e53616d0",
    primaryDescription:
      "A linked list is a dynamic data structure that consists of nodes, each containing data and a reference (link) to the next node in the sequence. This structure allows efficient insertions and deletions compared to static data structures like arrays. A linked list can be singly-linked (each node has a reference to the next node) or doubly-linked (each node has a reference to both the next and the previous nodes), and it may end with a node pointing to null (in a singly linked list) or to both null and the initial node (in a doubly linked circular list).",
    secondaryDescription:
      "Manipulating a linked list involves various operations like traversing (visiting each node), searching (finding a specific data item), insertion (adding a new node), and deletion (removing a node). These operations could have different time complexities depending on the specific implementation and the position of the operation. For example, insertion at the beginning of a linked list is generally an O(1) operation, whereas insertion at a particular position could be O(n), since you may need to traverse the list." +
      "" +
      "Linked lists serve as the foundation for other complex data structures like stacks, queues, and hash tables. They are also used in separate chaining, which is a common technique for implementing hash tables. Despite their simplicity, linked lists provide invaluable lessons about the organization of data and can be an essential topic for cracking coding interviews. Understanding the workings of linked lists will help you see how data can be efficiently managed and manipulated, even in large quantities.",
    videoURL: "https://www.youtube.com/embed/WwfhLC16bis",
    code: '\n// Import the LinkedList class\nimport java.util.LinkedList;\n\npublic class Main {\n  public static void main(String[] args) {\n    LinkedList<String> cars = new LinkedList<String>();\n    cars.add("Volvo");\n    cars.add("BMW");\n    cars.add("Ford");\n    cars.add("Mazda");\n    System.out.println(cars);\n  }\n}',
  },
  {
    _id: "64b06ad156a41ebc96130c62",
    primaryDescription:
      "Trees are one of the most common non-linear data structures in computer science, used for representing hierarchical relationships between objects. A tree data structure has a root, branches, and leaves. The top node is called the root, and from the root, zero or more nodes can be derived, which forms the branches and leaves. The nodes that are directly under a given node are called its children, and the node above is called its parent. Nodes with the same parent are called siblings. A node with no children is called a leaf node.",
    secondaryDescription:
      "Trees are used in many areas of computer science, including operating systems, graphics, database systems, and computer networking. Tree data structures like binary trees, binary search trees, AVL trees, and B-trees, among others, are extensively used in algorithms and problem solving. For example, a binary search tree is a tree that has the property where the key in each node must be greater than or equal to any key stored in the left sub-tree, and less than or equal to any key stored in the right sub-tree. This property makes the binary search tree an ordered or sorted binary tree, which allows operations like search, minimum, maximum, insert, and delete to be performed efficiently. Understanding the different types of trees, their properties, and use cases is fundamental to many aspects of software development and problem solving in technical interviews.\
    ",
    videoURL: "https://www.youtube.com/embed/1-l_UOFi1Xw",
    code: "\n// Class containing left and right child\n// of current node and key value\nclass Node {\n    int key;\n    Node left, right;\n \n    public Node(int item)\n    {\n        key = item;\n        left = right = null;\n    }\n}",
  },
  {
    _id: "64b06c391035f07b0f5f65f8",
    primaryDescription:
      "A heap is a specialized tree-based data structure in computer science that fulfills the heap property. In a heap, for any given node I, the value of I is greater than or equal to the values of its children (in a max heap) or less than or equal to the values of its children (in a min heap). This property makes a heap useful in sorting algorithms, such as heapsort. Heaps are also utilized in implementing efficient priority queues, which are pivotal in certain graph algorithms like Dijkstra's or Prim's algorithm. The highest (or lowest) priority element is always stored at the root, which makes the operations like insert, delete, and extract max or min more efficient.\
    ",
    secondaryDescription:
      "Understanding heaps and their operations is crucial for technical interviews because they're frequently used in numerous computational tasks. The insertion into a heap and deletion from a heap (both operations crucial in a priority queue) have a time complexity of O(log n), making it efficient for large datasets. Various types of heaps exist including binary heaps, Fibonacci heaps, and binomial heaps, each with their specific applications, benefits, and drawbacks. Binary heaps are the simplest form of heaps, and they serve as the foundation for understanding more complex heap structures. In the course of your study, you'll learn to implement a heap, perform basic operations, and apply heaps to solve complex problems often encountered in technical interviews.",
    videoURL: "https://www.youtube.com/embed/t0Cq6tVNRBA",
    code: "public class MinHeap {\n    private int[] heap;\n    private int size;\n\n    public MinHeap(int capacity) {\n        heap = new int[capacity];\n        size = 0;\n    }\n\n    private int getParentIndex(int childIndex) { return (childIndex - 1) / 2; }\n    private int getLeftChildIndex(int parentIndex) { return 2 * parentIndex + 1; }\n    private int getRightChildIndex(int parentIndex) { return 2 * parentIndex + 2; }\n\n    private boolean hasParent(int index) { return getParentIndex(index) >= 0; }\n    private boolean hasLeftChild(int index) { return getLeftChildIndex(index) < size; }\n    private boolean hasRightChild(int index) { return getRightChildIndex(index) < size; }\n\n    private int parent(int index) { return heap[getParentIndex(index)]; }\n    private int leftChild(int index) { return heap[getLeftChildIndex(index)]; }\n    private int rightChild(int index) { return heap[getRightChildIndex(index)]; }\n\n    public void add(int value) {\n        ensureExtraCapacity();\n        heap[size] = value;\n        size++;\n        heapifyUp();\n    }\n\n    public int peek() {\n        if (size == 0) throw new IllegalStateException();\n        return heap[0];\n    }\n\n    public int poll() {\n        if (size == 0) throw new IllegalStateException();\n        int value = heap[0];\n        heap[0] = heap[size - 1];\n        size--;\n        heapifyDown();\n        return value;\n    }\n\n    private void heapifyUp() {\n        int index = size - 1;\n        while (hasParent(index) && parent(index) > heap[index]) {\n            swap(getParentIndex(index), index);\n            index = getParentIndex(index);\n        }\n    }\n\n    private void heapifyDown() {\n        int index = 0;\n        while (hasLeftChild(index)) {\n            int smallerChildIndex = getLeftChildIndex(index);\n            if (hasRightChild(index) && rightChild(index) < leftChild(index)) {\n                smallerChildIndex = getRightChildIndex(index);\n            }\n\n            if (heap[index] < heap[smallerChildIndex]) {\n                break;\n            } else {\n                swap(index, smallerChildIndex);\n            }\n\n            index = smallerChildIndex;\n        }\n    }\n\n    private void swap(int indexOne, int indexTwo) {\n        int temp = heap[indexOne];\n        heap[indexOne] = heap[indexTwo];\n        heap[indexTwo] = temp;\n    }\n\n    private void ensureExtraCapacity() {\n        if (size == heap.length) {\n            heap = Arrays.copyOf(heap, size * 2);\n        }\n    }\n}\n",
  },
  {
    _id: "64b06fc8864d3dce86f3a3e7",
    primaryDescription: "Graphs are a fundamental and highly flexible data structure in computer science, utilized to represent various types of relational data. Essentially, a graph is a set of nodes, also known as vertices, connected by edges. Graphs can be categorized into two main types: directed and undirected. In an undirected graph, the edges between vertices have no direction, indicating a mutual relationship. For example, if two nodes represent two cities, the edge connecting them could symbolize a road, implying you can travel in either direction. On the other hand, in a directed graph, also known as a digraph, edges have an associated direction, signifying a one-way relationship.",
    secondaryDescription: "Graphs have a wide range of applications in numerous fields such as social networks, transportation networks, the internet, biology, computer graphics, and many more. Algorithms and techniques associated with graph theory are often used to solve complex problems in these domains. For example, Google\'s PageRank algorithm, which is used to rank web pages in their search engine results, is based on graph theory. In computer science, some common operations performed on graphs include traversal, path finding, and graph coloring. Graphs can be represented in multiple ways in memory using adjacency matrix, adjacency list, or incidence matrix depending on the specific requirements and trade-offs of the problem at hand.",
    videoURL: "https://www.youtube.com/embed/gXgEDyodOJU",
    code: "import java.util.*;\n\nclass Graph {\n\n    static void addEdge(ArrayList<ArrayList<Integer> > adj, int u, int v) {\n        adj.get(u).add(v);\n        adj.get(v).add(u);\n    }\n\n    static void printGraph(ArrayList<ArrayList<Integer> > adj) {\n        for (int i = 0; i < adj.size(); i++) {\n            System.out.println(\"\\nAdjacency list of vertex\" + i);\n            System.out.print(\"head\");\n            for (int j = 0; j < adj.get(i).size(); j++) {\n                System.out.print(\" -> \" + adj.get(i).get(j));\n            }\n            System.out.println();\n        }\n    }\n\n    public static void main(String[] args) {\n        int V = 5;\n        ArrayList<ArrayList<Integer> > adj = new ArrayList<ArrayList<Integer> >(V);\n\n        for (int i = 0; i < V; i++)\n            adj.add(new ArrayList<Integer>());\n\n        addEdge(adj, 0, 1);\n        addEdge(adj, 0, 4);\n        addEdge(adj, 1, 2);\n        addEdge(adj, 1, 3);\n        addEdge(adj, 1, 4);\n        addEdge(adj, 2, 3);\n        addEdge(adj, 3, 4);\n\n        printGraph(adj);\n    }\n}",
  },
  {
    _id: "64b070dc699bd986d145a182",
    primaryDescription: "Dynamic programming is a powerful computational optimization technique that has been widely used in computer science and mathematical optimization for solving complex problems by breaking them down into simpler subproblems. It revolves around the idea of solving each smaller subproblem only once, and storing the result of each of these solved subproblems, typically in an array or a similar data structure. This concept of storing the results of intermediate subproblems instead of recomputing them is called memoization. By avoiding repeated computations and leveraging the results of previously solved subproblems, dynamic programming often allows us to significantly improve the efficiency of algorithms, particularly for problems involving optimization, combinatorics, and graph theory.",
    secondaryDescription: "The key to successful dynamic programming is the principle of optimality, which asserts that an optimal policy has the property that whatever the initial state and initial decision are, the remaining decisions must constitute an optimal policy with regard to the state resulting from the first decision. The process generally involves defining a series of stages, with each stage representing a subset of the decision problem and the sequence of stages leading to an optimal policy. These stages are then solved iteratively, in a bottom-up manner, starting with the simplest subproblem. The application of dynamic programming is vast and can be found in various fields including economics, genomic research, and artificial intelligence to name a few.",
    videoURL: "https://www.youtube.com/embed/vYquumk4nWw",
    code: "class Main {\n    // Function to find nth fibonacci number\n    public static int fib(int n)\n    {\n        if (n <= 1) {\n            return n;\n        }\n        int x = fib(n - 1);\n        int y = fib(n - 2);\n \n        return x + y;\n    }\n \n    // Driver Code\n    public static void main(String[] args)\n    {\n        int n = 5;\n \n        // Function Call\n        System.out.print(fib(n));\n    }\n}",
  },
  // add more contents here...
];

export async function seedContents() {
  await Content.deleteMany({});
  console.log("Old contents cleared");
  await Content.insertMany(contents);
  console.log("Content data seeding completed");
}
